/**
 * Minimal Anchor client script for the voting program.
 * - Connects to a Solana cluster (localnet by default).
 * - Loads the program IDL from the generated JSON.
 * - Demonstrates init_poll and vote calls.
 * Wrap inside a real UI for production use.
 */
import * as anchor from "@coral-xyz/anchor"; // Anchor TypeScript SDK.
import { Program } from "@coral-xyz/anchor"; // Program client for invoking instructions.
import { PublicKey, SystemProgram, Keypair, Connection } from "@solana/web3.js"; // Core Solana types.
import dotenv from "dotenv"; // Loads environment variables from .env files.
import fs from "fs"; // File system access for reading keypairs.
import os from "os"; // OS helpers to locate the home directory.
import path from "path"; // Path helpers for cross-platform file paths.
// IDL will be generated by `anchor build`; import the JSON when available.
// eslint-disable-next-line @typescript-eslint/no-var-requires
type VotingIdl = anchor.Idl & { address?: string }; // Allow optional address field in the IDL JSON.
const idl = require("../target/idl/voting.json") as VotingIdl; // Load the compiled IDL.

// Replace with your deployed program id (must match Anchor.toml and Rust declare_id!).
const PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");

// Load `.env.local` / `.env` so PRIVATE_KEY and optional RPC override are available.
dotenv.config();

/**
 * Loads a keypair from PRIVATE_KEY (base58) or falls back to ~/.config/solana/id.json.
 */
function loadKeypair(): Keypair {
  const envKey = process.env.PRIVATE_KEY; // PRIVATE_KEY is a base58-encoded secret array.
  if (envKey && envKey.length > 0) {
    const secret = anchor.utils.bytes.bs58.decode(envKey); // Decode base58 into bytes.
    return Keypair.fromSecretKey(secret); // Create a Keypair from the secret bytes.
  }
  const file = process.env.ANCHOR_WALLET ?? path.join(os.homedir(), ".config", "solana", "id.json"); // Default Solana key location.
  const raw = JSON.parse(fs.readFileSync(file, "utf-8")) as number[]; // Read and parse the keypair file.
  return Keypair.fromSecretKey(Uint8Array.from(raw)); // Construct the Keypair from the numeric array.
}

/**
 * Builds an Anchor provider backed by a keypair and a Connection.
 */
function getProvider(): anchor.AnchorProvider {
  const rpcUrl = process.env.SOLANA_RPC_URL || "http://127.0.0.1:8899"; // Use env override or local validator.
  const connection = new Connection(rpcUrl, "confirmed"); // RPC connection with confirmed commitment.
  const wallet = new anchor.Wallet(loadKeypair()); // Anchor Wallet wrapper around the keypair.
  return new anchor.AnchorProvider(connection, wallet, { commitment: "confirmed" }); // Provider bundles connection + wallet.
}

/**
 * Helper to derive the Poll PDA exactly as the on-chain program expects.
 */
function derivePollPda(authority: PublicKey, title: string): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("poll"), authority.toBuffer(), Buffer.from(title)], // Seeds: static tag + authority + title.
    PROGRAM_ID // Program ID to bind the PDA space.
  );
}

/**
 * Helper to derive the Voter PDA: unique per (poll, wallet).
 */
function deriveVoterPda(poll: PublicKey, wallet: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("voter"), poll.toBuffer(), wallet.toBuffer()], // Seeds: static tag + poll + wallet.
    PROGRAM_ID
  );
}

async function main() {
  const provider = getProvider(); // Build the provider from RPC + wallet.
  anchor.setProvider(provider); // Set as global provider for Anchor APIs.
  if (!idl.address) {
    idl.address = PROGRAM_ID.toBase58(); // Ensure IDL carries the program address for Program constructor.
  }
  const program = new Program<VotingIdl>(idl, provider); // Create a typed Program client.

  // Example authority and poll config; replace for real inputs.
  const authority = provider.wallet as anchor.Wallet; // Wallet acting as poll authority.
  const title = "Studentski parlament 2025"; // Poll title string.
  const candidates = ["Ana", "Marko", "Ivana"]; // Candidate list.
  const startTs = Math.floor(Date.now() / 1000) + 60; // Start in 1 minute (unix seconds).
  const endTs = startTs + 3600; // End 1 hour after start.

  // Derive poll PDA; used for both init and vote.
  const [pollPda] = derivePollPda(authority.publicKey, title); // PDA is deterministic from authority+title.

  // INIT POLL (authority only). Skip if already created; will error if account exists.
  console.log("Sending init_poll...");
  await program.methods
    .initPoll(title, candidates, new anchor.BN(startTs), new anchor.BN(endTs)) // Pass args as Anchor BN where needed.
    .accounts({
      poll: pollPda, // PDA to create for the poll.
      authority: authority.publicKey, // Authority signs and pays.
      systemProgram: SystemProgram.programId, // Required for account creation.
    })
    .rpc(); // Send the transaction.
  console.log("Poll created at", pollPda.toBase58()); // Log the poll address.

  // VOTE (any wallet). In real app, gate via Firebase Auth + wallet adapter UI.
  const [voterPda] = deriveVoterPda(pollPda, authority.publicKey); // PDA unique to (poll, wallet).
  console.log("Casting vote for candidate 0...");
  await program.methods
    .vote(0) // Vote for candidate index 0.
    .accounts({
      poll: pollPda, // Poll account to update.
      authority: authority.publicKey, // Stored authority (not a signer here).
      voter: voterPda, // PDA that marks this wallet as having voted.
      wallet: authority.publicKey, // Wallet that signs and pays rent for voter PDA.
      systemProgram: SystemProgram.programId, // Needed to create voter account.
    })
    .rpc(); // Send the transaction.
  console.log("Vote submitted by", authority.publicKey.toBase58()); // Log who voted.
}

// Run the script and surface errors cleanly.
main().catch((err) => {
  console.error(err); // Print any error for debugging.
  process.exit(1); // Non-zero exit on failure.
});
